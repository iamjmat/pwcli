#!/usr/bin/env python
#
# Copyright (c) 2015, The Linux Foundation.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

import xmlrpclib
import base64
import logging
import sys
import subprocess
import readline
import argparse
import os
import ConfigParser
import email
import email.mime.text
import email.header
import smtplib
import pprint
import re
import timeit

PWCLI_EDIT_FILE = '.pwcli-edit'

DEFAULT_EDITOR = 'nano'

# global variables
logger = logging.getLogger('pwcli')

LOG_SEPARATOR = '\n---\n'

PATCH_STATE_NEW = 'New'
PATCH_STATE_UNDER_REVIEW = 'Under Review'
PATCH_STATE_ACCEPTED = 'Accepted'
PATCH_STATE_REJECTED = 'Rejected'
PATCH_STATE_RFC = 'RFC'
PATCH_STATE_NOT_APPLICABLE = 'Not Applicable'
PATCH_STATE_CHANGES_REQUESTED = 'Changes Requested'
PATCH_STATE_AWAITING_UPSTREAM = 'Awaiting Upstream'
PATCH_STATE_SUPERSEDED = 'Superseded'
PATCH_STATE_DEFERRED = 'Deferred'

def utf8(buf):
   return unicode(buf).encode('utf-8')

def clean(buf):
    buf = buf.translate(None, '\n\t')
    buf = buf.strip()
    return buf

def pretty(obj):
   return pprint.pformat(obj, indent=4)

# parses a string like '1-3,5' and returns the indexes in a list [1, 2, 3, 5]
def parse_list(entries):

   ids = []

   for entry in entries:
      (start_str, sep, end_str) = entry.partition('-')

      if not start_str.isdigit:
         print 'Not a digit: %s' % (start_str)
         return []

      start = int(start_str)

      if sep != '-':
         # entry is just one value
         ids.append(start)
         continue

      # entry is a region

      if not end_str.isdigit:
         print 'Not a digit: %s' % (end_str)
         return []

      end = int(end_str)

      # when we say 0-5 we also want the index 5, not just 0-4
      end += 1

      ids += range(start, end)

   ids = sorted(ids)

   # remove duplicate entries (didn't find any clever way to do this)
   #
   # remember to copy the list as you cannot modify the list you are
   # currently iterating!
   prev = None
   for val in list(ids):
      if val == prev:
         ids.remove(val)
         continue

      prev = val

   return ids

class Timer():

   def start(self):
      self.start_time = timeit.default_timer()

   def stop(self):
      self.end_time = timeit.default_timer()

   def get_seconds(self):
      return self.end_time - self.start_time

class GitError(Exception):

   def __str__(self):
      return self.msg

   def __init__(self, msg):
      self.msg = msg

class Stg():

   def import_patch(self, mbox):
      cmd = ['stg', 'import', '--mbox', '--sign']

      if self.dry_run:
            self.output('Dry-run: %s' % str(cmd))
            return

      logger.debug('stg.import_patch(): %s' % (mbox))

      p = subprocess.Popen(cmd, stdin = subprocess.PIPE)
      p.communicate(mbox)

      ret = p.returncode
      logger.debug('%s returned: %s' % (cmd, ret))

      if ret != 0:
         raise GitError('%s failed: %s' % (cmd, ret))

   def get_series(self):
      cmd = ['stg', 'series', '--noprefix', '--all']

      output = subprocess.check_output(cmd)
      output = output.strip()

      result = output.splitlines()

      logger.debug('stg.get_series(): %s', result)
      return result

   def get_commit(self, patchname):
      result = {}
      cmd = ['stg', 'show', patchname]

      output = subprocess.check_output(cmd)
      output = output.strip()

      match = re.search(r'^commit ([0-9a-f]{40})$', output, re.MULTILINE)
      if match == None:
         self.output('Commit id not found from patch: %s' % patchname)
         return None

      result['commit_id'] = match.group(1)

      match = re.search(r'^\s*Patchwork-Id:\s*(\d+)$', output, re.MULTILINE)
      if match == None:
         self.output('Patchwork id not found from patch: %s' % patchname)
         return None

      result['patchwork_id'] = match.group(1)

      return result

   def __init__(self, dry_run, output):
      self.dry_run = dry_run
      self.output = output

class Git():

   def get_commit(self, commitid):
      result = {}
      cmd = ['git', 'show', commitid]

      output = subprocess.check_output(cmd)
      output = output.strip()

      match = re.search(r'^commit ([0-9a-f]{40})$', output, re.MULTILINE)
      if match == None:
         self.output('Commit id not found from patch: %s' % commitid)
         return None

      result['commit_id'] = match.group(1)

      return result

   def log_oneline(self, max_count):
      cmd = ['git', 'log', '--oneline', '--reverse',
             '--max-count', str(max_count)]
      output = subprocess.check_output(cmd)
      output = output.strip()

      return output

   def get_config(self, config):
      cmd = ['git', 'config', '--get', config]

      try:
         output = subprocess.check_output(cmd)
      except subprocess.CalledProcessError as e:
         logger.debug(e)
         return None

      return output.strip()

   def get_branch(self):
      cmd = ['git', 'branch']
      output = subprocess.check_output(cmd)

      # the current branch is prefixed with '*'
      for line in output.splitlines():
         tokens = line.split()
         if tokens[0] == '*' and len(tokens) > 1:
            return tokens[1]

      return None

   # removes a line matching filter from the commit in HEAD
   def filter_msg(self, filter_string):
      sed_cmd = 'sed -e "/%s/d"' % (filter_string)

      # --force switch is to work around error "Cannot create a new backup.
      # --A previous backup already exists in refs/original/"

      cmd = ['git', 'filter-branch', '--force', '--msg-filter', sed_cmd, 'HEAD^..HEAD']

      subprocess.check_output(cmd)

   def cherry_pick(self, commit_id):
      cmd = ['git', 'cherry-pick', commit_id]

      if self.dry_run:
            self.output('Dry-run: %s' % str(cmd))
            return

      subprocess.check_output(cmd)

      # FIXME: if the cherry-pick fails (conflicts or whatnot) we
      # should run git cherry-pick --abort to cleanup

   def checkout(self, branch):
      cmd = ['git', 'checkout', branch]
      subprocess.check_output(cmd)

   def am(self, mbox):
      cmd = ['git', 'am', '-s', '-3']

      if self.dry_run:
            self.output('Dry-run: %s' % str(cmd))
            return

      p = subprocess.Popen(cmd, stdin = subprocess.PIPE)
      p.communicate(mbox)

      ret = p.returncode
      logger.debug('%s returned: %s' % (cmd, ret))

      if ret != 0:
         abort_cmd = ['git', 'am', '--abort']
         logger.debug('Aborting git am: %s' % abort_cmd)
         subprocess.call(abort_cmd)

         clean_cmd = ['git', 'checkout', '-f']
         logger.debug('Cleaning working tree: %s' % clean_cmd)
         subprocess.call(clean_cmd)

         raise GitError('%s failed: %s' % (cmd, ret))

   def __init__(self, dry_run, output):
      self.dry_run = dry_run
      self.output = output

class Patch():

   def get_name(self):
      return self.attributes['name']

   def get_id(self):
      return self.attributes['id']

   def get_delegate(self):
      return self.attributes['delegate']

   def get_state_id(self):
      return self.attributes['state_id']

   def get_state_name(self):
      return self.attributes['state']

   def set_state_name(self, state_name):
      if self.dry_run:
         logger.debug('dry-run: %s().set_state_name(%s)' % (self, state_name))
         return

      state_id = self.pw.get_state_id(state_name)
      
      params = {}
      params['state'] = state_id
      self.pw.rpc.patch_set(self.get_id(), params)

      self.attributes['state'] = state_name
      self.attributes['state_id'] = state_id

      logger.debug('%s state changed to %s' % (self.get_id(), state_id))

   def get_commit_ref(self):
      return self.attributes['commit_ref']

   def set_commit_ref(self, commit_ref):
      if self.dry_run:
         logger.debug('dry-run: %s().set_commit_ref(%s)' % (self, commit_ref))
         return

      params = {}
      params['commit_ref'] = commit_ref
      self.pw.rpc.patch_set(self.get_id(), params)

      self.attributes['commit_ref'] = commit_ref

      logger.debug('%s: commit_ref change to %s' % (self, commit_ref))

   def get_temp_ref(self):
      return self.temp_ref

   def set_temp_ref(self, temp_ref):
      self.temp_ref = temp_ref

   def get_url(self):
      return '%s%s/' % (self.pw.patch_url, self.get_id())

   def get_mbox(self):
      if self.mbox == None:
         logger.debug('patch_get_mbox(%s)' % self.get_id())
         self.mbox = self.pw.rpc.patch_get_mbox(self.get_id())
         logger.debug(repr(self.mbox))

      return utf8(self.mbox)

   # removes all extra '[ ]' tags _before_ the actual title
   def clean_subject(self, subject):
      # Note: '.*?' is a non-greedy version of '.*'

      return re.sub(r'^\s*(\[.*?\]\s*)*', '', subject)

   def get_mbox_for_stgit(self):
      msg = self.get_email()

      payload = msg.get_payload()

      # add Patchwork-Id with s/^---\n/Patchwork-Id: 1001\n---\n
      id_line = '\nPatchwork-Id: %s\n---\n' % (self.get_id())
      payload = re.sub(r'\n---\n', id_line, payload)
      msg.set_payload(payload)

      subject = self.clean_subject(msg['Subject'])
      msg.replace_header('Subject', subject)

      # Add a From header with unixfrom so that this is valid mbox
      # format, strangely patchwork doesn't add it.
      mbox = msg.as_string(unixfrom=True)

      return mbox

   def set_mbox(self, mbox):
      if self.dry_run:
         logger.debug('dry-run: %s().set_mbox(%s)' % (self, mbox))
         return

      logger.debug('%s: set_mbox(): %s' % (self, repr(mbox)))
      self.mbox = mbox

      # need to also update the name from mbox
      msg = self.get_email()
      self.attributes['name'] = msg['Subject']

   def get_diffstat(self):
      p = subprocess.Popen(['diffstat', '-p1'], stdout=subprocess.PIPE,
                           stdin=subprocess.PIPE,
                           stderr=subprocess.PIPE)

      diffstat = p.communicate(input=self.get_mbox())[0]
      diffstat = diffstat.rstrip()

      return diffstat

   def get_email(self):
      return email.message_from_string(self.get_mbox())

   def get_reply_msg(self, from_name, from_email, text=''):
      msg = self.get_email()

      (log, sep, patch) = msg.get_payload().partition(LOG_SEPARATOR)

      # create body
      quote = []

      from_entries = email.header.decode_header(msg['From'])
      logger.debug('from_entries %r' % (from_entries))

      if len(from_entries) == 0:
         raise Exception('Invalid From header: %r' % (msg['From']))

      (header_from, charset) = from_entries[0]

      # FIXME: what if charset is something else (iso-8859-1 etc), can
      # we use that still?
      if charset == 'utf-8' or charset == None:
         who = header_from
      else:
         who = None

      if who:
         quote.append('%s wrote:' % (who))

      for line in log.splitlines():
         quote.append('> %s' % line)

      quote.append('')

      body = '\n'.join(quote)

      # empty line after the quote
      body += '\n'

      body += text
      body += '\n%s\n' % self.get_email_signature()

      logger.debug('body=%s', repr(body))

      # avoid base64 encoding, a tip from http://bugs.python.org/issue12552
      email.charset.add_charset('utf-8', email.charset.SHORTEST)

      reply = email.mime.text.MIMEText(body, _charset='utf-8')

      # create cc list
      persons = []

      if 'To' in msg:
         persons += msg['To'].split(',')

      cc = []
      if 'Cc' in msg:
        persons += msg['Cc'].split(',')

        for person in persons:
           person = clean(person)

           # don't add my email in cc field
           if person.count(from_email) > 0:
              continue

           cc.append(person)

      from_hdr = '%s <%s>' % (from_name, from_email)
      subject_hdr = 'Re: %s' % clean(msg['Subject'])
      to_hdr = clean(msg['From'])
      cc_hdr = ', '.join(cc)

      reply['Subject'] = subject_hdr
      reply['From'] = from_hdr
      reply['In-Reply-To'] = msg['Message-Id']
      reply['References'] = msg['Message-Id']
      reply['To'] = to_hdr

      if len(cc_hdr) > 0:
         reply['Cc'] = cc_hdr

      logger.debug('%s().get_reply_msg(): %s', self, repr(quote))

      return reply

   def get_email_signature(self):
      signature = '-- \nSent by pwcli\n%s\n' % (self.get_url())

      return signature

   def get_log(self):
      msg = self.get_email()
      payload = msg.get_payload()

      (log, sep, patch) = payload.partition(LOG_SEPARATOR)

      return log.strip()

   def __str__(self):
       return 'Patch(name=%s, id=%s)' % (self.get_name(), self.get_id())

   def __init__(self, pw, attributes, dry_run):
      self.pw = pw
      self.attributes = attributes
      self.dry_run = dry_run

      self.mbox = None
      self.temp_ref = None

class Project():
   def _get_patches(self, filters, username=None):
      results = []

      logger.debug('%s()._get_patches(filters=%s)' % (self, repr(filters)))
      patches = self.pw.rpc.patch_list(filters)
      logger.debug('patches:\n%s' % pretty(patches))

      for p in patches:
         patch = Patch(self.pw, p, self.dry_run)

         if username != None and patch.get_delegate() != username:
            continue

         results.append(patch)
         logger.debug('added patch %s' % patch)

      return results

   def get_patches(self, state=PATCH_STATE_UNDER_REVIEW, username=None):
      filters = {}
      filters['project_id'] = self.id

      if state != None:
         filters['state_id'] = self.pw.get_state_id(state)

      return self._get_patches(filters, username)

   def get_patch(self, patchwork_id):
      filters = {}
      filters['id'] = patchwork_id

      results = self._get_patches(filters)

      if len(results) > 1:
         logger.debug('Multiple patches found with same patchwork id %s' % (patchwork_id))
         return None
      elif len(results) == 0:
         logger.debug('patchwork id %s not found' % (patchwork_id))
         return None

      return results[0]

   def __str__(self):
       return 'Project(name=%s, id=%s)' % (self.name, self.id)

   def __init__(self, name, pw, dry_run):
      self.name = name
      self.id = None
      self.pw = pw
      self.dry_run = dry_run

      logger.debug('project_list(%s, %d)' % (self.name, 0))
      projects = pw.rpc.project_list(self.name, 0)

      logger.debug('projects: %s' % pretty(projects))

      for project in projects:
         if project['linkname'] == self.name:
            self.id = project['id']

      if self.id == None:
         raise Exception('No project id found for %s' % self.name)

      logger.debug(self)

class AuthTransport(xmlrpclib.SafeTransport):
   def send_auth(self, connection):
      creds = base64.encodestring('%s:%s' % (self.username,
                                             self.password)).strip()
      auth_string = 'Basic ' + creds
      connection.putheader('Authorization', auth_string)

   def send_host(self, connection, host):
      xmlrpclib.Transport.send_host(self, connection, host)

      if self.username != None and self.password != None:
         self.send_auth(connection)

   def make_connection(self, host):
      if self.https:
         return xmlrpclib.SafeTransport.make_connection(self, host)
      else:
         return xmlrpclib.Transport.make_connection(self, host)

   def __init__(self, username = None, password = None, https = False):
      xmlrpclib.SafeTransport.__init__(self)

      self.username = username
      self.password = password
      self.https = https

class Patchwork():
   def update_state_list(self):
      logger.debug('patch_state_list()')
      self.states = self.rpc.state_list('', 0)
      logger.debug(repr(self.states))

   def get_state_id(self, state_name):
      for state in self.states:
         if state['name'] == state_name:
            return state['id']

   def get_user_ids(self, username):
      persons = self.rpc.person_list(username, 0)
      logger.debug('%s().get_user_id(%s):\n%s' % (self, username, pretty(persons)))

      ids = []

      for person in persons:
         if person['user'] == username:
            ids.append(person['id'])

      return ids
         
   def __init__(self, url, username, password):
      self.xmlrpc_url = url
      self.patch_url = url.replace('/xmlrpc/', '/patch/')
      https = url.startswith('https')
      transport = AuthTransport(username, password, https)
      self.rpc = xmlrpclib.Server(url, transport = transport)

      logger.debug('connected to %s (username %s)' % (url, username))

      self.update_state_list()

class PWCLI():

   # retrieve all mbox files in one for "smoother user experience"
   def prefetch_patches(self, patches):
      i = 1
      for patch in patches:
         print '\rRetrieving patches (%d/%d)' % (i, len(patches)),
         sys.stdout.flush()

         patch.get_mbox()
         i += 1

   def get_patches_from_ids(self, ids):
      indexes = parse_list(ids)

      if self.patches == None:
         raise Exception('No patches listed, forgot to run list command?')

      if len(self.patches) == 0:
         raise Exception('No patches available, doing nothing.')
         return

      # sanity check and populate selected[]
      selected_patches = []
      for index in indexes:
         if index > len(self.patches):
            raise Exception('Patch index %d not found, max %d' %
                            (index, len(self.patches)))

         if index - 1 < 0:
            self.output('Invalid patch list index: %d %d' % (index))
            return

         selected_patches.append(self.patches[index - 1])

      return selected_patches

   def open_browser_url(self, url):
      if not self.browser:
         return

      cmd = [self.browser, url]

      # to avoid call() unnecessarily spamming stdout and stderr
      devnull = open(os.devnull, "w")

      returncode = subprocess.call(cmd, stdout=devnull, stderr=devnull)

      devnull.close()

      logger.debug('PWCLI.open_browser_url(url=%r): return code %d' % (url,
                                                                       returncode))

   def create_patchlist_as_string(self, patches, show_indexes=False,
                                  open_browser=False):
      i = 1
      index = ''
      result = ''

      for patch in patches:
         if show_indexes:
            index = '[%3d] ' % (i)

         result += '%s%s %s\n' % (index, patch.get_id(), patch.get_name())
         if open_browser:
            self.open_browser_url(patch.get_url())

         i += 1

      return result.strip('\n')

   def send_email(self, msg):
      logger.debug('%s.send_email(msg=%s)' % (self, repr(msg)))

      # FIXME: check that email configs are set

      if 'From' not in msg:
         self.output('No From header found in the message')
         return

      if 'To' not in msg:
         self.output('No To header found in the message')
         return

      envelope_from = msg['From']

      envelope_to = []
      for person in msg['To'].split(','):
         envelope_to.append(clean(person))
      
      if 'Cc' in msg:
         for person in msg['Cc'].split(','):
            envelope_to.append(clean(person))

      logger.debug('%s.send_email(): %s -> %s\n%r' % (self,
                                                      envelope_from,
                                                      envelope_to,
                                                      msg.as_string()))

      if self.dry_run:
         self.output('Dry-run: %s -> %s' % (envelope_from, envelope_to))
         return

      try:
         server = smtplib.SMTP(self.smtp_host, self.smtp_port)

         if self.smtp_encryption == 'tls':
            server.starttls()

         if self.smtp_username != None and self.smtp_password != None:
            server.login(self.smtp_username, self.smtp_password)

         server.sendmail(envelope_from, envelope_to, msg.as_string())
         server.quit()
      except smtplib.SMTPException as e:
         self.output('Failed to send email via %s: %s' % (self.smtp_host, e))
         return

      logger.debug('email sent to %s:%s' % (self.smtp_host, self.smtp_port))

   def edit_email(self, msg):
      logger.debug('%s.edit_email(msg=%r)' % (self, msg.as_string()))

      while True:

         if 'From' not in msg:
            self.output('No From header found in the message')
            return

         if 'To' not in msg:
            self.output('No To header found in the message')
            return

         envelope_from = msg['From']

         envelope_to = []
         for person in msg['To'].split(','):
            envelope_to.append(clean(person))
      
         if 'Cc' in msg:
            for person in msg['Cc'].split(','):
               envelope_to.append(clean(person))

         self.output('============================================================')
         self.output(msg.as_string())
         self.output('============================================================')

         self.output('Envelope From: %s' % envelope_from)
         self.output('Envelope To: %s' % envelope_to)

         answer = self.input('Send/Edit/Abort? ')
         answer = answer.lower()

         if answer == 's':
            # Send
            return msg
         elif answer == 'e':
            # Edit
            buf = self.edit_file(msg.as_string())
            msg = email.message_from_string(buf)
         elif answer == 'a':
            # Abort
            self.output('Aborted send email')
            return None
         else:
            self.output('Unknown choise: %s' % (answer))

      # should not reach this
      return None

   def edit_file(self, buf):
      f = open(PWCLI_EDIT_FILE, 'w')
      f.write(buf)
      f.close()

      subprocess.call([self.editor, PWCLI_EDIT_FILE])

      f = open(PWCLI_EDIT_FILE, 'r')
      new_buf = f.read()
      f.close

      os.remove(PWCLI_EDIT_FILE)

      return new_buf

   def show_patch(self, patch):
      self.output('============================================================')
      self.output(patch.get_name())
      self.output('')
      self.output('%s%s%s' % (patch.get_log(), LOG_SEPARATOR, patch.get_diffstat()))
      self.output('============================================================')

   def show_info(self):
      user_ids = ', '.join(str(v) for v in self.user_ids)

      self.print_header('User', '%s (%s)' % (self.username, user_ids))
      self.print_header('Projects', ' '.join(self.project_names))
      self.print_header('Tree', self.tree)

      if self.pending_mode == 'stgit':
         self.print_header('Main branches', ' '.join(self.main_branches))
         self.print_header('Pending branch', self.pending_branch)
      else:
         self.print_header('Branch', self.git.get_branch())

      if self.default_filter_delegated:
         username = self.username
      else:
         username = None

      # in stgit mode we should get the count from the pending branch
      if self.pending_mode == 'stgit':
         review = len(self.get_pending_branch_patches())
      else:
         review = len(self.project.get_patches(PATCH_STATE_UNDER_REVIEW, username))

      new = len(self.project.get_patches(PATCH_STATE_NEW, username))
      upstream = len(self.project.get_patches(PATCH_STATE_AWAITING_UPSTREAM, username))
      deferred = len(self.project.get_patches(PATCH_STATE_DEFERRED, username))
      total = new + review + upstream + deferred

      self.print_header(PATCH_STATE_NEW, new)
      self.print_header('Review', review)
      self.print_header('Upstream', upstream)
      self.print_header(PATCH_STATE_DEFERRED, deferred)
      self.print_header('Total', total)

   def run_build_script(self):
      cmd = self.build_command

      if not cmd:
         # build command is not specified, skip the build
         return

      if self.dry_run:
            self.output('Dry-run: %s' % str(cmd))
            return

      empty_line = '                                                                 '
      stdoutdata = ''
      stderrdata = ''

      self.timer.start()
      p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

      lines = iter(p.stdout.readline, '')
      for line in lines:
         stdoutdata += line
         print '\r%s\r%s' % (empty_line, line.replace('\n', '')),

      stderrdata = p.stderr.read()

      p.stdout.close()
      p.stderr.close()
      returncode = p.wait()

      self.timer.stop()

      logger.debug('Build \'%s\' done in %.1fs: (%r, %r, %r)' %
                   (cmd, self.timer.get_seconds(), returncode,
                    stdoutdata, stderrdata))

      # empty the line from "status" messages
      print '\r%s\r' % (empty_line),

      if returncode != 0:
         self.output(stderrdata.strip())
         self.output('Build failed: %d' % (returncode))
      elif len(stderrdata) > 0:
         self.output(stderrdata.strip())
         self.output('Build failed with warnings')
      else:
         self.output('Build succesful')

   def get_pending_branch_patches(self):
      patches = []

      self.git.checkout(self.pending_branch)

      stg_series = self.stg.get_series()

      # FIXME: add "progress bar" as patches are retrieved from the
      # server and can take sometime
      for stg_commit_name in stg_series:
         c = self.stg.get_commit(stg_commit_name)

         if c == None:
            continue

         patchwork_id = int(c['patchwork_id'])
         patch = self.project.get_patch(patchwork_id)

         if not patch:
            self.output('Patch id %s not found' % (c['patchwork_id']))
            continue

         # patches in pending branch can be applied, tests or
         # whatever, so skip those
         if patch.get_state_name() != PATCH_STATE_UNDER_REVIEW:
            continue

         # store the commit id so that we can use it when cherry picking
         # the patch
         patch.set_temp_ref(c['commit_id'])

         patches.append(patch)

      return patches

   def cmd_help(self, args):
      logger.debug('cmd_help(args=%s)' % repr(args))
      self.parser.print_help()

   def cmd_quit(self, args):
      logger.debug('cmd_quit(args=%s)' % repr(args))
      sys.exit(0)

   def cmd_list(self, args):
      logger.debug('cmd_list(args=%s)' % repr(args))

      if args.state == 'review':
         state = PATCH_STATE_UNDER_REVIEW
      elif args.state == 'upstream':
         state = PATCH_STATE_AWAITING_UPSTREAM
      elif args.state == 'new':
         state = PATCH_STATE_NEW
      elif args.state == 'deferred':
         state = PATCH_STATE_DEFERRED
      elif args.state == None:
         # default
         state = PATCH_STATE_UNDER_REVIEW
      else:
         self.output('Unknown state: %s' % args.state)
         return

      if self.default_filter_delegated:
         username = self.username
      else:
         username = None

      if self.pending_mode == 'stgit' and state == PATCH_STATE_UNDER_REVIEW:
         self.patches = self.get_pending_branch_patches()
      else:
         self.patches = self.project.get_patches(state, username)

      # filter patches
      for patch in self.patches:
         if args.subject:
            match = re.search(args.subject[0], patch.get_name(),
                              re.MULTILINE | re.IGNORECASE)
            if not match:
               self.patches.remove(patch)
               continue

      self.output(self.create_patchlist_as_string(self.patches,
                                                  show_indexes=True))

   def cmd_commit(self, args):
      logger.debug('cmd_commit(args=%s)' % repr(args))
      selected = self.get_patches_from_ids(args.ids)

      self.prefetch_patches(selected)

      # newline to clear the "progress bar"
      self.output('')

      self.output(self.create_patchlist_as_string(selected,
                                                  show_indexes=False,
                                                  open_browser=True))

      self.output('------------------------------------------------------------')
      self.output('%d patches' % len(selected))

      while True:
         answer = self.input('commit All/commit Individually/aBort? ')
         answer = answer.lower()

         valid = ['a', 'i', 'b']

         if answer in valid:
            break

         self.output('Unknown choise \'%s\', valid choises are: %s' % (answer,
                                                                       ', '.join(valid)))

      if answer == 'a':
         # commit All
         commit_individually = False

      if answer == 'i':
         # commit Individually
         commit_individually = True

      if answer == 'b':
         # aBort
         self.output('Aborted commit command')
         return

      if self.pending_mode == 'stgit':
         self.git.checkout(self.selected_main_branch)

      num = 1
      applied = []
      skipped = []
      for patch in selected:
         skip = False

         while commit_individually:
            # FIXME: in stgit mode we should show the commit log from
            # pending branch
            self.show_patch(patch)

            answer = None

            while True:
               answer = self.input('[%d/%d] Commit/Edit/Skip/Abort? ' % (num,
                                                                         len(selected)))
               answer = answer.lower()

               valid = ['c', 'e', 's', 'a']

               if answer in valid:
                  break

               self.output('Unknown choise \'%s\', valid choises are: %s' % (answer,
                                                                          ', '.join(valid)))

            if answer == 'a':
               self.output('Commit command aborted')
               return

            if answer == 's':
               self.output('Skipping patch')
               skip = True
               break

            if answer == 'e':
               mbox = patch.get_mbox()
               new_mbox = self.edit_file(mbox)

               if mbox != new_mbox:
                  patch.set_mbox(new_mbox)

               continue

            if answer == 'c':
               # continue with commit process
               break

         num += 1

         if skip:
            skipped.append(patch)
            continue

         # apply the patch
         try:
            if self.pending_mode == 'stgit':
               # FIXME: add sanity check that the patch really is in
               # review state. Also applies to main ('non-pending')
               # mode?

               # The pwcli commit command always requires the list
               # command to be run first, which always sets the
               # temp_ref (in stgit mode) so we can assume that the
               # patch has correct commit_ref set.
               self.git.cherry_pick(patch.get_temp_ref())

               # FIXME: remove Patchwork-Id from the commit log
               # git commit --amend --file=-
               # better:
               # git filter-branch --msg-filter 'sed -e "//d"' HEAD^..HEAD
               self.git.filter_msg('^Patchwork-Id:')
            else:
               self.git.am(patch.get_mbox())

            # store the commit id temporarily
            c = self.git.get_commit('HEAD')
            patch.set_temp_ref(c['commit_id'])

            applied.append(patch)

            # FIXME: Retrieve the commit id and set commit_ref so that
            # the commit id is visible in the web interface and it's
            # possible to find the patchwork id based on commit id.
         except GitError as e:
            self.output('Failed to apply the patch: %s' % e)
            skipped.append(patch)

      # FIXME: should also summary if none of the patches were applied
      if len(applied) == 0:
         return

      # show summary in the shell
      self.output('============================================================')
      self.output('%d patches applied:' % len(applied))
      self.output('')
      self.output(self.git.log_oneline(len(applied)))
      self.output('')

      if len(skipped) > 0:
         self.output('%d patches skipped:' % len(skipped))
         self.output('')

         for patch in skipped:
            self.output(patch.get_name())

         self.output('')

      # create the "Thanks, applied" email
      payload = ''
      tree_name = '%s.git' % self.tree

      # FIXME: what if len(applied) is zero?

      if len(applied) == 1:
         patches_str = 'patch'
      else:
         patches_str = 'patches'

      if self.pending_mode == 'stgit' and len(self.main_branches) > 1:
         branch_name = '%s branch of ' % (self.selected_main_branch)
      else:
         branch_name = ''

      payload += 'Thanks, %d %s applied to %s%s:\n\n' % (len(applied),
                                                       patches_str,
                                                         branch_name,
                                                       tree_name)
      payload += '%s\n' % self.git.log_oneline(len(applied))

      if len(skipped) > 0:
         payload += '\n%d patches skipped:\n\n' % len(skipped)
         for patch in skipped:
            payload += '%s\n' % patch.get_name()

      patch = applied[0]
      reply = patch.get_reply_msg(self.fullname, self.email, payload)

      while True:

         while True:
            choices = 'Accept/request Changes/Reject/Show mail/Edit mail/aBort? '
            answer = self.input(choices)
            answer = answer.lower()

            valid = ['a', 'c', 'r', 's', 'e', 'b']

            if answer in valid:
               break

            self.output('Unknown choise \'%s\', valid choises are: %s' % (answer,
                                                                       ', '.join(valid)))

         if answer == 'a':
            # Accept
            for patch in applied:
               patch.set_state_name(PATCH_STATE_ACCEPTED)
               patch.set_commit_ref(patch.get_temp_ref())

            self.output('%d patches accepted, %d skipped' % (len(applied),
                                                             len(skipped)))

            # FIXME: what to do if there are skipped patches?
            self.send_email(reply)

            self.output('Email sent')

            break

         if answer == 'c':
            # request Changes

            # sets all patches to 'Changes Requested' and creates an
            # email requesting changes (send_email(edit=True))
            self.output('FIXME: implement')

         if answer == 'r':
            # Reject
            # sets all patches to 'Rejected' and creates an
            # email stating the reason (send_email(edit=True))
            self.output('FIXME: implement')

         if answer == 's':
            # Show mail
            self.output(reply.as_string())

         if answer == 'e':
            # Edit mail
            buf = self.edit_file(reply.as_string())

            # FIXME: check if the mail is malformed
            reply = email.message_from_string(buf)

         if answer == 'b':
            # aBort
            self.output('Aborted commit command')
            return

   def cmd_show(self, args):
      logger.debug('cmd_show(args=%s)' % repr(args))

      selected_patches = self.get_patches_from_ids(args.ids)

      if len(selected_patches) == 1:
         patch = selected_patches[0]
         self.show_patch(patch)
         self.open_browser_url(patch.get_url())
      elif len(selected_patches) > 1:
         self.output(self.create_patchlist_as_string(selected_patches,
                                                     show_indexes=False,
                                                     open_browser=True))
      else:
         # FIXME: what to do if we don't find any patches?
         pass

   def cmd_review(self, args):
      logger.debug('cmd_review(args=%r)' % args)

      selected_patches = self.get_patches_from_ids(args.ids)

      self.prefetch_patches(selected_patches)

      # force a newline so that new text starts from it's own line
      self.output('')

      self.output(self.create_patchlist_as_string(selected_patches,
                                                  show_indexes=True,
                                                  open_browser=True))

      self.output('------------------------------------------------------------')

      applied = []
      skipped = []

      if self.pending_mode == 'stgit':
         while True:
            choises = 'Apply %d patches to the pending branch? [Apply/Skip/aBort] ' % len(selected_patches)
            answer = self.input(choises)
            answer = answer.lower()

            valid = ['a', 's', 'b']

            if answer in valid:
               break

            self.output('Unknown choise \'%s\', valid choises are: %s' % (answer,
                                                                          ', '.join(valid)))

         # Apply
         if answer == 'a':
            # git checkout self.pending_branch
            self.git.checkout(self.pending_branch)
         
            for patch in selected_patches:
               # stg import --sign
               # FIXME: catch GitError
               try:
                  self.stg.import_patch(patch.get_mbox_for_stgit())
                  applied.append(patch)
               except GitError as e:
                  self.output('Failed to apply patch: %s' % e)
                  skipped.append(patch)
         # Skip
         elif answer == 's':
            # do nothing, just continue to state handling
            pass
         # aBort
         elif answer == 'b':
            return

      else:
         # stgit disabled, no need to apply any patches
         applied = selected_patches


      while True:
         choices = 'Under review/Changes requested/Deferred/Rejected/aBort? '
         answer = self.input(choices)
         answer = answer.lower()

         valid = ['u', 'c', 'd', 'r', 'b']

         if answer in valid:
            break

         self.output('Unknown choise \'%s\', valid choises are: %s' % (answer,
                                                                       ', '.join(valid)))

      reply_text = None
      if len(selected_patches) > 1:
         patches_word = 'Patches have'
      else:
         patches_word = 'The patch has'

      # Under review
      if answer == 'u':
         state = PATCH_STATE_UNDER_REVIEW
      # Changes requested
      elif answer == 'c':
         state = PATCH_STATE_CHANGES_REQUESTED
         reply_text = '%s been dropped, please resend.' % (patches_word)
      # Deferred
      elif answer == 'd':
         state = PATCH_STATE_DEFERRED
         pass
      # Rejected
      elif answer == 'r':
         state = PATCH_STATE_REJECTED
         reply_text = '%s been dropped.' % (patches_word)
      # aBort
      elif answer == 'b':
         self.output('Aborted.')
         return
      else:
         # should not be reached
         assert(False)

      for patch in selected_patches:
         patch.set_state_name(state)

      if reply_text:
         first_patch = selected_patches[0]

         reply_text += '\n'

         # No point adding patchlist for a single patch, it doesn't
         # bring any extra value which isn't already in the title or
         # in the signature.
         if len(selected_patches) > 1:
            reply_text += '\n%s\n' % (self.create_patchlist_as_string(selected_patches))

         reply = first_patch.get_reply_msg(self.fullname, self.email,
                                           reply_text)

         reply = self.edit_email(reply)

         if reply == None:
            # user aborted
            return

         self.send_email(reply)

      # FIXME: print summary of applied and skipped patches (with totals)
      self.output('%d patches set to %s, %d applied and %d not applied' %
                  (len(selected_patches), state, len(applied), len(skipped)))

   def cmd_reply(self, args):
      logger.debug('cmd_reply(args=%s)' % repr(args))

      try:
         i = int(args.id[0])
      except ValueError as e:
         self.output('Failed to convert index to integer: %s' % e)
         return

      if self.patches == None:
         self.output('No patches listed, forgot to run list command?')
         return

      if i > len(self.patches):
         self.output('Patch index %d not found' % i)
         return

      patch = self.patches[i - 1]
      reply = patch.get_reply_msg(self.fullname, self.email)

      reply = self.edit_email(reply)

      if reply == None:
         return
      
      self.send_email(reply)

   def cmd_info(self, args):
      logger.debug('cmd_info(args=%s)' % repr(args))

      self.show_info()

   def cmd_build(self, args):
      logger.debug('cmd_build(args=%s)' % repr(args))

      self.run_build_script()

   def cmd_project(self, args):
      logger.debug('cmd_project(args=%r)' % repr(args))

      if args.index == None:
         self.output('Projects:')
         i = 0
         for project in self.projects:
            if self.project == project:
               selected = '*'
            else:
               selected = ' '

            self.output('%s %d: %s' % (selected, i, project.name))

            i += 1

         return

      try:
         index = int(args.index)
      except ValueError as e:
         self.output('Failed to convert index to integer: %s' % e)
         return

      self.project = self.projects[index]

      self.output('Switched to project: %s' % (self.project.name))

   def cmd_branch(self, args):
      logger.debug('cmd_branch(args=%r)' % repr(args))

      if args.index == None:
         self.output('Main branches:')
         i = 0
         for branch in self.main_branches:
            if self.selected_main_branch == branch:
               selected = '*'
            else:
               selected = ' '

            self.output('%s %d: %s' % (selected, i, branch))

            i += 1

         return

      try:
         index = int(args.index)
      except ValueError as e:
         self.output('Failed to convert index to integer: %s' % e)
         return

      if index > len(self.main_branches) - 1:
         self.output('index out of bounds: %d' % index)
         return

      self.selected_main_branch = self.main_branches[index]

      self.output('Switched main branch to: %s' % (self.selected_main_branch))

   def run_shell(self):
      index_help = 'the indexes of the patches to be committed from the previous list command, example: 5-8,10'

      self.parser = argparse.ArgumentParser(description='pwcli - patchwork client shell. More help for individual commands with --help switch',
                                            prog='',
                                            add_help=False)
   
      subparsers = self.parser.add_subparsers()

      subparsers.add_parser('help').set_defaults(func=self.cmd_help,
                                                 help='show summary of available commands')

      subparsers.add_parser('quit').set_defaults(func=self.cmd_quit,
                                                 help='quit the shell')
      subparsers.add_parser('q').set_defaults(func=self.cmd_quit,
                                              help='quit the shell')

      parser_list = subparsers.add_parser('list', 
                                          help='list patches from patchwork',
                                          description='Fetches patches from patchwork based on various filters and shows the summary with indexes')
      parser_list.add_argument('state', metavar='STATE', nargs='?',
                               help='optional patch state: new, review (default), upstream, deferred')
      parser_list.add_argument('--subject', '-s',
                               metavar='REGEXP', nargs=1,
                               help='show only patches with subject matching REGEXP (case is ingored)')
      parser_list.set_defaults(func=self.cmd_list)

      parser_commit = subparsers.add_parser('commit',
                                            help='commit list of patches',
                                            description='Commits one or more patches using git, changes the state of patches accordingly and sends an email reply. Requires that the list command is run before.')
      parser_commit.add_argument('ids', metavar='IDS', nargs='+',
                                 help=index_help)
      parser_commit.set_defaults(func=self.cmd_commit)

      parser_review = subparsers.add_parser('review',
                                            help='review patches and change states',
                                            description='Opens each patch in a brower window for easy review of the patch and comments. Provides options to change states')
      parser_review.add_argument('ids', metavar='IDS', nargs='+',
                                 help=index_help)
      parser_review.set_defaults(func=self.cmd_review)

      parser_show = subparsers.add_parser('show',
                                          help='show information about the patches',
                                          description='Show information about the patches and open browser window for each')
      parser_show.add_argument('ids', metavar='IDS', nargs='+',
                               help=index_help)
      parser_show.set_defaults(func=self.cmd_show)

      parser_reply = subparsers.add_parser('reply',
                                           help='send an email reply to the patch')
      parser_reply.add_argument('id', metavar='ID', nargs=1,
                                help='patch index from list command')
      parser_reply.set_defaults(func=self.cmd_reply)

      parser_project = subparsers.add_parser('project',
                                             help='switch between patchwork projects',
                                             description='Switch between patchwork projects, if no index is specified list of projects is shown with indexes.')
      parser_project.add_argument('index', metavar='INDEX', nargs='?',
                                  help='patchwork project index')
      parser_project.set_defaults(func=self.cmd_project)

      parser_project = subparsers.add_parser('branch',
                                             help='switch between git branches',
                                             description='Switch between git branches, if no branch index specified list of available branches is shown with indexes.')
      parser_project.add_argument('index', metavar='INDEX', nargs='?',
                                  help='branch index')
      parser_project.set_defaults(func=self.cmd_branch)

      subparsers.add_parser('info').set_defaults(func=self.cmd_info,
                                                 help='show various patchwork statistics')

      subparsers.add_parser('build').set_defaults(func=self.cmd_build,
                                                 help='run build script and show results')

      while True:
         prompt = ''

         if self.pending_mode == 'stgit':
            branch = self.selected_main_branch
         else:
            branch = self.git.get_branch()
         prompt += '%s@%s ' % (branch, self.tree)

         if self.dry_run:
            prompt += '(dry-run)'

         prompt += '> '

         cmd = self.input(prompt)

         # argparse is idiotic and exits if there's a parse error,
         # workaround it by catching SystemExit. Idea from:
         #
         # http://bugs.python.org/issue9938
         try:
            args = self.parser.parse_args(cmd.split())
         except SystemExit:
            continue

         args.func(args)

   def print_header(self, name, value):
      fmt = "%- 14s: %s"
      self.output(fmt % (name, value))

   def output(self, buf):
      logger.debug('> \'%s\'' % buf)
      print buf

   def input(self, prompt):
      logger.debug('> \'%s\'' % prompt)
      cmd = raw_input(prompt)
      logger.debug('< \'%s\'' % cmd)

      return cmd

   def __init__(self):
      self.timer = Timer()

      if 'GIT_DIR' in os.environ:
         self.git_dir = os.environ['GIT_DIR']
      else:
         self.git_dir = '.git'

      self.pwcli_dir = os.path.join(self.git_dir, 'pwcli')
      self.config_file = os.path.join(self.pwcli_dir, 'config')

      if not os.path.exists(self.pwcli_dir):
         print '%s does not exist, exiting' % self.pwcli_dir
         sys.exit(1)

      if not os.path.isdir(self.pwcli_dir):
         print '%s is not a directory, exiting' % self.pwcli_dir
         sys.exit(1)

      if os.path.exists(PWCLI_EDIT_FILE):
         print '%s exists, remove and try again.' % PWCLI_EDIT_FILE
         sys.exit(1)

      logging.basicConfig(filename=os.path.join(self.pwcli_dir, 'log'),
                          format='%(asctime)s %(levelname)s: %(message)s')

      parser = argparse.ArgumentParser(description='Patchwork Command-Line Interface')
      parser.add_argument('-d', '--debug', action='store_true',
                          help='enable debug messages')

      parser.add_argument('--dry-run', action='store_true',
                          help='Don\'t modify anything')

      args = parser.parse_args()

      if args.debug:
         logger.setLevel(logging.DEBUG)

      logger.debug('pwcli args %s)' % repr(args))

      self.dry_run = args.dry_run

      self.config = ConfigParser.RawConfigParser()

      if not os.path.exists(self.config_file):
         print 'Could not find %s', self.config_file
         sys.exit(1)

      self.config.read(self.config_file)

      # read settings from pwcli config file
      self.url = self.config.get('general', 'url')
      self.username = self.config.get('general', 'username')
      self.password = self.config.get('general', 'password')

      if self.config.has_option('general', 'build-command'):
         self.build_command = self.config.get('general', 'build-command')
      else:
         self.build_command = None

      self.project_names = self.config.get('general', 'project')

      self.project_names = self.project_names.split()

      # FIXME: ConfigParser supports providing defaults as a dict, use
      # those instead. Also maybe it's better to use self.config
      # directly and get rid of self.foo properties?

      if self.config.has_option('general', 'default_filter_delegated'):
         self.default_filter_delegated = self.config.getboolean('general',
                                                                'default_filter_delegated')
      else:
         self.default_filter_delegated = True

      if self.config.has_option('general', 'browser'):
         self.browser = self.config.get('general', 'browser')
      else:
         self.browser = None

      pending_modes = ['disabled', 'stgit']

      # defaults
      self.pending_mode = 'disabled'
      self.pending_branch = None
      self.main_branches = None

      if self.config.has_option('general', 'pending_mode'):
         self.pending_mode = self.config.get('general', 'pending_mode').lower()

      if self.pending_mode not in pending_modes:
         self.output('Invalid stgit.mode "%s"' % self.pending_mode)
         sys.exit(1)

      if self.config.has_option('general', 'pending_branch'):
         self.pending_branch = self.config.get('general', 'pending_branch').lower()

      if self.config.has_option('general', 'main_branches'):
         branches = self.config.get('general', 'main_branches').lower()
         self.main_branches = branches.split()
         self.selected_main_branch = self.main_branches[0]

      if self.pending_mode == 'stgit':
         if self.pending_branch == None:
            self.output('general.pending_branch not set')
            sys.exit(1)

         if self.main_branches == None:
            self.output('general.main_branches not set')
            sys.exit(1)

      # read settings from environment variables
      if 'EDITOR' in os.environ:
         self.editor = os.environ['EDITOR']
      else:
         self.editor = DEFAULT_EDITOR

      self.git = Git(self.dry_run, self.output)
      self.stg = Stg(self.dry_run, self.output)

      # read settings from git
      self.fullname = self.git.get_config('user.name')
      self.email = self.git.get_config('user.email')
      self.smtp_host = self.git.get_config('sendemail.smtpserver')
      self.smtp_port = self.git.get_config('sendemail.smtpserverport')
      self.smtp_encryption = self.git.get_config('sendemail.smtpencryption')
      self.smtp_username = self.git.get_config('sendemail.smtpuser')
      self.smtp_password = self.git.get_config('sendemail.smtppass')

      # print configs to debug log
      logger.debug('fullname=%s' % self.fullname)
      logger.debug('email=%s' % self.email)
      logger.debug('url=%s' % self.url)
      logger.debug('username=%s' % self.username)
      logger.debug('project_name=%s' % self.project_names)
      logger.debug('editor=%s' % self.editor)
      logger.debug('smtp_host=%s' % self.smtp_host)
      logger.debug('smtp_port=%s' % self.smtp_port)
      logger.debug('smtp_encryption=%s' % self.smtp_encryption)
      logger.debug('smtp_username=%s' % self.smtp_username)

      if self.smtp_password != None:
         passwd = '<hidden>'
      else:
         passwd = '<not set>'

      logger.debug('smtp_password=%s' % passwd)
      
      self.output('Connecting to %s' % self.url)

      self.pw = Patchwork(self.url, self.username, self.password)

      self.projects = []
      for project_name in self.project_names:
         self.projects.append(Project(project_name, self.pw, self.dry_run))

      # select the first project as initial project
      self.project = self.projects[0]

      self.user_ids = self.pw.get_user_ids(self.username)
      self.tree = os.path.basename(os.getcwd())

      self.patches = None

      self.show_info()

def main():
   pwcli = PWCLI()
   pwcli.run_shell()

if __name__ == "__main__":
   main()
