#!/usr/bin/env python
#
# Copyright (c) 2015, The Linux Foundation.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

import xmlrpclib
import base64
import logging
import sys
import subprocess
import readline
import argparse
import os
import ConfigParser
import email
import email.mime.text
import smtplib
import pprint
import re

PWCLI_EDIT_FILE = '.pwcli-edit'

DEFAULT_EDITOR = 'nano'

# global variables
logger = logging.getLogger('pwcli')

LOG_SEPARATOR = '\n---\n'

def utf8(buf):
   return unicode(buf).encode('utf-8')

def clean(buf):
    buf = buf.translate(None, '\n\t')
    buf = buf.strip()
    return buf

def pretty(obj):
   return pprint.pformat(obj, indent=4)

# parses a string like '1-3,5' and returns the indexes in a list [1, 2, 3, 5]
def parse_list(entries):

   ids = []

   for entry in entries:
      (start_str, sep, end_str) = entry.partition('-')

      if not start_str.isdigit:
         print 'Not a digit: %s' % (start_str)
         return []

      start = int(start_str)

      if sep != '-':
         # entry is just one value
         ids.append(start)
         continue

      # entry is a region

      if not end_str.isdigit:
         print 'Not a digit: %s' % (end_str)
         return []

      end = int(end_str)

      # when we say 0-5 we also want the index 5, not just 0-4
      end += 1

      ids += range(start, end)

   ids = sorted(ids)

   # remove duplicate entries (didn't find any clever way to do this)
   #
   # remember to copy the list as you cannot modify the list you are
   # currently iterating!
   prev = None
   for val in list(ids):
      if val == prev:
         ids.remove(val)
         continue

      prev = val

   return ids

class GitError(Exception):

   def __str__(self):
      return self.msg

   def __init__(self, msg):
      self.msg = msg

class Stg():

   def import_patch(self, mbox):
      cmd = ['stg', 'import', '--mbox', '--sign']

      if self.dry_run:
            self.output('Dry-run: %s' % str(cmd))
            return

      logger.debug('stg.import_patch(): %s' % (mbox))

      p = subprocess.Popen(cmd, stdin = subprocess.PIPE)
      p.communicate(mbox)

      ret = p.returncode
      logger.debug('%s returned: %s' % (cmd, ret))

      if ret != 0:
         raise GitError('%s failed: %s' % (cmd, ret))

   def get_series(self):
      cmd = ['stg', 'series', '--noprefix', '--all']

      output = subprocess.check_output(cmd)
      output = output.strip()

      result = output.splitlines()

      logger.debug('stg.get_series(): %s', result)
      return result

   def get_commit(self, patchname):
      result = {}
      cmd = ['stg', 'show', patchname]

      output = subprocess.check_output(cmd)
      output = output.strip()

      match = re.search(r'^commit ([0-9a-f]{40})$', output, re.MULTILINE)
      if match == None:
         self.output('Commit id not found from patch: %s' % patchname)
         return None

      result['commit_id'] = match.group(1)

      match = re.search(r'^\s*Patchwork-Id:\s*(\d+)$', output, re.MULTILINE)
      if match == None:
         self.output('Patchwork id not found from patch: %s' % patchname)
         return None

      result['patchwork_id'] = match.group(1)

      return result

   def __init__(self, dry_run, output):
      self.dry_run = dry_run
      self.output = output

class Git():

   def log_oneline(self, max_count):
      cmd = ['git', 'log', '--oneline', '--reverse',
             '--max-count', str(max_count)]
      output = subprocess.check_output(cmd)
      output = output.strip()

      return output

   def get_config(self, config):
      cmd = ['git', 'config', '--get', config]

      try:
         output = subprocess.check_output(cmd)
      except subprocess.CalledProcessError as e:
         logger.debug(e)
         return None

      return output.strip()

   def get_branch(self):
      cmd = ['git', 'branch']
      output = subprocess.check_output(cmd)

      # the current branch is prefixed with '*'
      for line in output.splitlines():
         tokens = line.split()
         if tokens[0] == '*' and len(tokens) > 1:
            return tokens[1]

      return None

   # removes a line matching filter from the commit in HEAD
   def filter_msg(self, filter_string):
      sed_cmd = 'sed -e "/%s/d"' % (filter_string)

      # --force switch is to work around error "Cannot create a new backup.
      # --A previous backup already exists in refs/original/"

      cmd = ['git', 'filter-branch', '--force', '--msg-filter', sed_cmd, 'HEAD^..HEAD']

      subprocess.check_output(cmd)

   def cherry_pick(self, commit_id):
      cmd = ['git', 'cherry-pick', commit_id]
      subprocess.check_output(cmd)

      # FIXME: if the cherry-pick fails (conflicts or whatnot) we
      # should run git cherry-pick --abort to cleanup

   def checkout(self, branch):
      cmd = ['git', 'checkout', branch]
      subprocess.check_output(cmd)

   def am(self, mbox):
      cmd = ['git', 'am', '-s', '-3']

      if self.dry_run:
            self.output('Dry-run: %s' % str(cmd))
            return

      p = subprocess.Popen(cmd, stdin = subprocess.PIPE)
      p.communicate(mbox)

      ret = p.returncode
      logger.debug('%s returned: %s' % (cmd, ret))

      if ret != 0:
         abort_cmd = ['git', 'am', '--abort']
         logger.debug('Aborting git am: %s' % abort_cmd)
         subprocess.call(abort_cmd)

         clean_cmd = ['git', 'checkout', '-f']
         logger.debug('Cleaning working tree: %s' % clean_cmd)
         subprocess.call(clean_cmd)

         raise GitError('%s failed: %s' % (cmd, ret))

   def __init__(self, dry_run, output):
      self.dry_run = dry_run
      self.output = output

class Patch():

   def get_name(self):
      return self.attributes['name']

   def get_id(self):
      return self.attributes['id']

   def get_delegate(self):
      return self.attributes['delegate']

   def get_state_id(self):
      return self.attributes['state_id']

   def get_state_name(self):
      return self.attributes['state']

   def set_state_name(self, state_name):
      if self.dry_run:
         logger.debug('dry-run: %s().set_state_name(%s)' % (self, state_name))
         return

      state_id = self.pw.get_state_id(state_name)
      
      params = {}
      params['state'] = state_id
      self.pw.rpc.patch_set(self.get_id(), params)

      self.attributes['state'] = state_name
      self.attributes['state_id'] = state_id

      logger.debug('%s state changed to %s' % (self.get_id(), state_id))

   def get_commit_ref(self):
      return self.attributes['commit_ref']

   def set_commit_ref(self, commit_ref):
      if self.dry_run:
         logger.debug('dry-run: %s().set_commit_ref(%s)' % (self, commit_ref))
         return

      params = {}
      params['commit_ref'] = commit_ref
      self.pw.rpc.patch_set(self.get_id(), params)

      self.attributes['commit_ref'] = commit_ref

      logger.debug('%s: commit_ref change to %s' % (self, commit_ref))

   def get_mbox(self):
      if self.mbox == None:
         logger.debug('patch_get_mbox(%s)' % self.get_id())
         self.mbox = self.pw.rpc.patch_get_mbox(self.get_id())
         logger.debug(repr(self.mbox))

      return utf8(self.mbox)

   # removes all extra '[ ]' tags _before_ the actual title
   def clean_subject(self, subject):
      # Note: '.*?' is a non-greedy version of '.*'

      return re.sub(r'^\s*(\[.*?\]\s*)*', '', subject)

   def get_mbox_for_stgit(self):
      msg = self.get_email()

      payload = msg.get_payload()

      # add Patchwork-Id with s/^---\n/Patchwork-Id: 1001\n---\n
      id_line = 'Patchwork-Id: %s\n---\n' % (self.get_id())
      payload = re.sub(r'\n---\n', id_line, payload)
      msg.set_payload(payload)

      subject = self.clean_subject(msg['Subject'])
      msg.replace_header('Subject', subject)

      # Add a From header with unixfrom so that this is valid mbox
      # format, strangely patchwork doesn't add it.
      mbox = msg.as_string(unixfrom=True)

      return mbox

   def set_mbox(self, mbox):
      if self.dry_run:
         logger.debug('dry-run: %s().set_mbox(%s)' % (self, mbox))
         return

      logger.debug('%s: set_mbox(): %s' % (self, repr(mbox)))
      self.mbox = mbox

      # need to also update the name from mbox
      msg = self.get_email()
      self.attributes['name'] = msg['Subject']

   def get_diffstat(self):
      p = subprocess.Popen(['diffstat', '-p1'], stdout=subprocess.PIPE,
                           stdin=subprocess.PIPE,
                           stderr=subprocess.PIPE)

      diffstat = p.communicate(input=self.get_mbox())[0]
      diffstat = diffstat.rstrip()

      return diffstat

   def get_email(self):
      return email.message_from_string(self.get_mbox())

   def get_reply_msg(self, from_name, from_email):
      msg = self.get_email()

      (log, sep, patch) = msg.get_payload().partition(LOG_SEPARATOR)

      # create body
      quote = []

      # FIXME: add 'Foo wrote:'

      quote.append('')

      for line in log.splitlines():
         quote.append('> %s' % line)

      quote.append('')

      body = '\n'.join(quote)

      logger.debug('body=%s', repr(body))

      # FIXME: should use utf-8
      reply = email.mime.text.MIMEText(body, _charset='us-ascii')

      # create cc list
      persons = []

      if 'To' in msg:
         persons += msg['To'].split(',')

      cc = []
      if 'Cc' in msg:
        persons += msg['Cc'].split(',')

        for person in persons:
           person = clean(person)

           # don't add my email in cc field
           if person.count(from_email) > 0:
              continue

           cc.append(person)

      from_hdr = '%s <%s>' % (from_name, from_email)
      subject_hdr = 'Re: %s' % clean(msg['Subject'])
      to_hdr = clean(msg['From'])
      cc_hdr = ', '.join(cc)

      reply['Subject'] = subject_hdr
      reply['From'] = from_hdr
      reply['In-Reply-To'] = msg['Message-Id']
      reply['To'] = to_hdr

      if len(cc_hdr) > 0:
         reply['Cc'] = cc_hdr

      logger.debug('%s().get_reply_msg(): %s', self, repr(quote))

      return reply

   def get_log(self):
      msg = self.get_email()
      payload = msg.get_payload()

      (log, sep, patch) = payload.partition(LOG_SEPARATOR)

      return log.strip()

   def __str__(self):
       return 'Patch(name=%s, id=%s)' % (self.get_name(), self.get_id())

   def __init__(self, pw, attributes, dry_run):
      self.pw = pw
      self.attributes = attributes
      self.dry_run = dry_run

      self.mbox = None

class Project():
   def _get_patches(self, filters, username=None):
      results = []

      logger.debug('%s()._get_patches(filters=%s)' % (self, repr(filters)))
      patches = self.pw.rpc.patch_list(filters)
      logger.debug('patches:\n%s' % pretty(patches))

      for p in patches:
         patch = Patch(self.pw, p, self.dry_run)

         if username != None and patch.get_delegate() != username:
            continue

         results.append(patch)
         logger.debug('added patch %s' % patch)

      return results

   def get_patches(self, state='Under Review', username=None):
      filters = {}
      filters['project_id'] = self.id

      if state != None:
         filters['state_id'] = self.pw.get_state_id(state)

      return self._get_patches(filters, username)

   def get_patch(self, patchwork_id):
      filters = {}
      filters['id'] = patchwork_id

      results = self._get_patches(filters)

      if len(results) > 1:
         self.output('Multiple patches found with same patchwork id %s' % (patchwork_id))
         return None
      elif len(results) == 0:
         self.output('patchwork id %s not found' % (patchwork_id))
         return None

      return results[0]

   def __str__(self):
       return 'Project(name=%s, id=%s)' % (self.name, self.id)

   def __init__(self, name, pw, dry_run):
      self.name = name
      self.id = None
      self.pw = pw
      self.dry_run = dry_run

      logger.debug('project_list(%s, %d)' % (self.name, 0))
      projects = pw.rpc.project_list(self.name, 0)

      logger.debug('projects: %s' % pretty(projects))

      for project in projects:
         if project['linkname'] == self.name:
            self.id = project['id']

      if self.id == None:
         raise Exception('No project id found for %s' % self.name)

      logger.debug(self)

class AuthTransport(xmlrpclib.SafeTransport):
   def send_auth(self, connection):
      creds = base64.encodestring('%s:%s' % (self.username,
                                             self.password)).strip()
      auth_string = 'Basic ' + creds
      connection.putheader('Authorization', auth_string)

   def send_host(self, connection, host):
      xmlrpclib.Transport.send_host(self, connection, host)

      if self.username != None and self.password != None:
         self.send_auth(connection)

   def make_connection(self, host):
      if self.https:
         return xmlrpclib.SafeTransport.make_connection(self, host)
      else:
         return xmlrpclib.Transport.make_connection(self, host)

   def __init__(self, username = None, password = None, https = False):
      xmlrpclib.SafeTransport.__init__(self)

      self.username = username
      self.password = password
      self.https = https

class Patchwork():
   def update_state_list(self):
      logger.debug('patch_state_list()')
      self.states = self.rpc.state_list('', 0)
      logger.debug(repr(self.states))

   def get_state_id(self, state_name):
      for state in self.states:
         if state['name'] == state_name:
            return state['id']

   def get_user_ids(self, username):
      persons = self.rpc.person_list(username, 0)
      logger.debug('%s().get_user_id(%s):\n%s' % (self, username, pretty(persons)))

      ids = []

      for person in persons:
         if person['user'] == username:
            ids.append(person['id'])

      return ids
         
   def __init__(self, url, username, password):
      https = url.startswith('https')
      transport = AuthTransport(username, password, https)
      self.rpc = xmlrpclib.Server(url, transport = transport)

      logger.debug('connected to %s (username %s)' % (url, username))

      self.update_state_list()

class PWCLI():

   def send_email(self, msg):
      logger.debug('%s.send_email(msg=%s)' % (self, repr(msg)))

      # FIXME: check that email configs are set

      while True:

         if 'From' not in msg:
            self.output('No From header found in the message')
            return

         if 'To' not in msg:
            self.output('No To header found in the message')
            return

         envelope_from = msg['From']

         envelope_to = []
         for person in msg['To'].split(','):
            envelope_to.append(clean(person))
      
         if 'Cc' in msg:
            for person in msg['Cc'].split(','):
               envelope_to.append(clean(person))

         self.output('============================================================')
         self.output(msg.as_string())
         self.output('============================================================')

         self.output('Envelope From: %s' % envelope_from)
         self.output('Envelope To: %s' % envelope_to)

         answer = self.input('Send/Edit/Abort? ')
         answer = answer.lower()

         if answer == 'a':
            self.output('Aborted send email')
            return

         if answer == 'e':
            buf = self.edit_file(msg.as_string())
            msg = email.message_from_string(buf)
            continue

         if answer == 's':
            # send email
            break

      logger.debug('sending email %s -> %s: %s' % (envelope_from, envelope_to,
                                                   repr(str(msg))))

      if self.dry_run:
         self.output('Dry-run: %s -> %s' % (envelope_from, envelope_to))
         return

      try:
         server = smtplib.SMTP(self.smtp_host, self.smtp_port)

         if self.smtp_encryption == 'tls':
            server.starttls()

         if self.smtp_username != None and self.smtp_password != None:
            server.login(self.smtp_username, self.smtp_password)

         server.sendmail(envelope_from, envelope_to, msg.as_string())
         server.quit()
      except smtplib.SMTPException as e:
         self.output('Failed to send email via %s: %s' % (self.smtp_host, e))
         return

      logger.debug('email sent to %s:%s' % (self.smtp_host, self.smtp_port))

   def edit_file(self, buf):
      f = open(PWCLI_EDIT_FILE, 'w')
      f.write(buf)
      f.close()

      subprocess.call([self.editor, PWCLI_EDIT_FILE])

      f = open(PWCLI_EDIT_FILE, 'r')
      new_buf = f.read()
      f.close

      os.remove(PWCLI_EDIT_FILE)

      return new_buf

   def show_patch(self, patch):
      self.output('============================================================')
      self.output(patch.get_name())
      self.output('')
      self.output('%s%s%s' % (patch.get_log(), LOG_SEPARATOR, patch.get_diffstat()))
      self.output('============================================================')

   def show_info(self):
      user_ids = ', '.join(str(v) for v in self.user_ids)

      self.print_header('User', '%s (%s)' % (self.username, user_ids))
      self.print_header('Projects', ' '.join(self.project_names))
      self.print_header('Tree', self.tree)

      if self.pending_mode == 'stgit':
         self.print_header('Main branch', self.main_branch)
         self.print_header('Pending branch', self.pending_branch)
      else:
         self.print_header('Branch', self.git.get_branch())

      if self.default_filter_delegated:
         username = self.username
      else:
         username = None

      # in stgit mode we should get the count from the pending branch
      if self.pending_mode == 'stgit':
         review = len(self.get_pending_branch_patches())
      else:
         review = len(self.project.get_patches('Under Review', username))

      new = len(self.project.get_patches('New', username))
      upstream = len(self.project.get_patches('Awaiting Upstream', username))
      deferred = len(self.project.get_patches('Deferred', username))
      total = new + review + upstream + deferred

      self.print_header('New', new)
      self.print_header('Review', review)
      self.print_header('Upstream', upstream)
      self.print_header('Deferred', deferred)
      self.print_header('Total', total)

   def get_pending_branch_patches(self):
      patches = []

      self.git.checkout(self.pending_branch)

      stg_series = self.stg.get_series()

      # FIXME: add "progress bar" as patches are retrieved from the
      # server and can take sometime
      for stg_commit_name in stg_series:
         c = self.stg.get_commit(stg_commit_name)

         if c == None:
            continue

         patch = self.project.get_patch(c['patchwork_id'])

         # Set commit_ref so that we can use it when commiting the
         # patch. This is actually stored to the server as well, even
         # though it's not really needed in the server at this stage.
         # This round trip also slows down the execution but I don't
         # worry about speed right now.
         patch.set_commit_ref(c['commit_id'])

         patches.append(patch)

      return patches

   def cmd_help(self, args):
      logger.debug('cmd_help(args=%s)' % repr(args))
      self.parser.print_help()

   def cmd_quit(self, args):
      logger.debug('cmd_quit(args=%s)' % repr(args))
      sys.exit(0)

   def cmd_list(self, args):
      logger.debug('cmd_list(args=%s)' % repr(args))

      if args.state == 'review':
         state = 'Under Review'
      elif args.state == 'upstream':
         state = 'Awaiting Upstream'
      elif args.state == 'new':
         state = 'New'
      elif args.state == 'deferred':
         state = 'Deferred'
      elif args.state == None:
         # default
         state = 'Under Review'
      else:
         self.output('Unknown state: %s' % args.state)
         return

      if self.default_filter_delegated:
         username = self.username
      else:
         username = None

      if self.pending_mode == 'stgit' and state == 'Under Review':
         self.patches = self.get_pending_branch_patches()
      else:
         self.patches = self.project.get_patches(state, username)

      index = 1
      for patch in self.patches:
         self.output('[%3d] %s %s' % (index, patch.get_id(), patch.get_name()))
         index += 1

   def cmd_commit(self, args):
      logger.debug('cmd_commit(args=%s)' % repr(args))
      indexes = parse_list(args.ids)
      selected = []

      if self.patches == None:
         self.output('No patches listed, forgot to run list command?')
         return

      if len(self.patches) == 0:
         self.output('No patches available, doing nothing.')
         return

      # sanity check and populate selected[]
      for index in indexes:
         if index - 1 > len(self.patches):
            self.output('Patch index %d not found, max %d' %
                        (index, len(self.patches)))
            return

         if index - 1 < 0:
            self.output('Invalid patch list index: %d %d' % (index))
            return

         patch = self.patches[index - 1]
         selected.append(patch)

      # retrieve all mbox files in one for "smoother user experience"
      j = 1
      for patch in selected:
         print '\rRetrieving patches (%d/%d)' % (j, len(selected)),
         sys.stdout.flush()

         patch.get_mbox()
         j += 1

      # newline to clear the "progress bar"
      self.output('')

      for patch in selected:
         self.output('%s %s' % (patch.get_id(), patch.get_name()))

      self.output('------------------------------------------------------------')
      self.output('%d patches' % len(selected))

      while True:
         answer = self.input('commit All/commit Individually/aBort? ')
         answer = answer.lower()

         valid = ['a', 'i', 'b']

         if answer in valid:
            break

         self.output('Unknown choise \'%s\', valid choises are: %s' % (answer,
                                                                       ', '.join(valid)))

      if answer == 'a':
         # commit All
         commit_individually = False

      if answer == 'i':
         # commit Individually
         commit_individually = True

      if answer == 'b':
         # aBort
         self.output('Aborted commit command')
         return

      if self.pending_mode == 'stgit':
         self.git.checkout(self.main_branch)

      num = 1
      applied = []
      skipped = []
      for patch in selected:
         skip = False

         while commit_individually:
            # FIXME: in stgit mode we should show the commit log from
            # pending branch
            self.show_patch(patch)

            answer = None

            while True:
               answer = self.input('[%d/%d] Commit/Edit/Skip/Abort? ' % (num,
                                                                         len(selected)))
               answer = answer.lower()

               valid = ['c', 'e', 's', 'a']

               if answer in valid:
                  break

               self.output('Unknown choise \'%s\', valid choises are: %s' % (answer,
                                                                          ', '.join(valid)))

            if answer == 'a':
               self.output('Commit command aborted')
               return

            if answer == 's':
               self.output('Skipping patch')
               skip = True
               break

            if answer == 'e':
               mbox = patch.get_mbox()
               new_mbox = self.edit_file(mbox)

               if mbox != new_mbox:
                  patch.set_mbox(new_mbox)

               continue

            if answer == 'c':
               # continue with commit process
               break

         num += 1

         if skip:
            skipped.append(patch)
            continue

         # apply the patch
         try:
            if self.pending_mode == 'stgit':
               # FIXME: add sanity check that the patch really is in
               # review state. Also applies to main ('non-pending')
               # mode?

               # The pwcli commit command always requires the list
               # command to be run first, which always sets the
               # commit_ref (in stgit mode) so we can assume that the
               # patch has correct commit_ref set.
               self.git.cherry_pick(patch.get_commit_ref())

               # FIXME: remove Patchwork-Id from the commit log
               # git commit --amend --file=-
               # better:
               # git filter-branch --msg-filter 'sed -e "//d"' HEAD^..HEAD
               self.git.filter_msg('^Patchwork-Id:')
            else:
               self.git.am(patch.get_mbox())

            applied.append(patch)

            # FIXME: Retrieve the commit id and set commit_ref so that
            # the commit id is visible in the web interface and it's
            # possible to find the patchwork id based on commit id.
         except GitError as e:
            self.output('Failed to apply the patch: %s' % e)
            skipped.append(patch)

      # FIXME: should also summary if none of the patches were applied
      if len(applied) == 0:
         return

      # show summary in the shell
      self.output('============================================================')
      self.output('%d patches applied:' % len(applied))
      self.output('')
      self.output(self.git.log_oneline(len(applied)))
      self.output('')

      if len(skipped) > 0:
         self.output('%d patches skipped:' % len(skipped))
         self.output('')

         for patch in skipped:
            self.output(patch.get_name())

         self.output('')

      while True:
         answer = self.input('Update state in patchwork? [y/N] ')
         answer = answer.lower()

         if answer == 'y':
            for patch in applied:
               patch.set_state_name('Accepted')

            break

         if answer == 'n' or len(answer) == 0:
            break

      # send "applied" email
      patch = applied[0]
      reply = patch.get_reply_msg(self.fullname, self.email)

      payload = reply.get_payload()
      tree_name = '%s.git' % self.tree

      # empty line after the quotation
      payload += '\n'

      # FIXME: what if len(applied) is zero?

      if len(applied) == 1:
         patches_str = 'patch'
      else:
         patches_str = 'patches'

      payload += 'Thanks, %d %s applied to %s:\n\n' % (len(applied),
                                                       patches_str,
                                                       tree_name)
      payload += '%s\n' % self.git.log_oneline(len(applied))

      if len(skipped) > 0:
         payload += '\n%d patches skipped:\n\n' % len(skipped)
         for patch in skipped:
            payload += '%s\n' % patch.get_name()

      payload += '\n%s\n' % self.fullname

      reply.set_payload(payload)

      self.send_email(reply)

   def cmd_show(self, args):
      logger.debug('cmd_show(args=%s)' % repr(args))

      try:
         i = int(args.id[0])
      except ValueError as e:
         self.output('Failed to convert index to integer: %s' % e)
         return

      patch = self.patches[i - 1]
      self.show_patch(patch)

   def cmd_review(self, args):
      logger.debug('cmd_review(args=%r)' % args)
      indexes = parse_list(args.ids)

      if self.patches == None:
         self.output('No patches listed, forgot to run list command?')
         return

      if len(self.patches) == 0:
         self.output('No patches available, doing nothing.')
         return

      for index in indexes:
         if index > len(self.patches):
            self.output('Patch index %d not found, max %d' %
                        (index, len(self.patches)))
            return

      selected_patches = []

      for i in indexes:
         selected_patches.append(self.patches[i - 1])

      # retrieve all mbox files in one for "smoother user experience"
      i = 1
      for patch in selected_patches:
         print '\rRetrieving patches (%d/%d)' % (i, len(selected_patches)),
         sys.stdout.flush()

         patch.get_mbox()
         i += 1

      # force a newline so that new text starts from it's own line
      self.output('')

      for patch in selected_patches:
         self.output('%s %s' % (patch.get_id(), patch.get_name()))

      self.output('------------------------------------------------------------')

      answer = self.input('Set to %d patch(es) to Under Review state? [y/N] ' % len(selected_patches))
      answer = answer.lower()

      if answer != 'y':
         return

      applied = []
      skipped = []
      if self.pending_mode == 'stgit':
         # git checkout self.pending_branch
         self.git.checkout(self.pending_branch)
         
         for patch in selected_patches:
            # stg import --sign
            # FIXME: catch GitError
            try:
               self.stg.import_patch(patch.get_mbox_for_stgit())
               applied.append(patch)
            except GitError as e:
               self.output('Failed to apply patch: %s' % e)
               skipped.append(patch)

      else:
         # stgit disabled, no need to apply any patches
         applied = selected_patches

      for patch in applied:
         patch.set_state_name('Under Review')

      # FIXME: print summary of applied and skipped patches (with totals)
      self.output('%d patches set to Under Review, %d skipped' % (len(applied), len(skipped)))

   def cmd_reply(self, args):
      logger.debug('cmd_reply(args=%s)' % repr(args))

      try:
         i = int(args.id[0])
      except ValueError as e:
         self.output('Failed to convert index to integer: %s' % e)
         return

      if self.patches == None:
         self.output('No patches listed, forgot to run list command?')
         return

      if i > len(self.patches):
         self.output('Patch index %d not found' % i)
         return

      patch = self.patches[i - 1]
      reply = patch.get_reply_msg(self.fullname, self.email)

      buf = self.edit_file(reply.as_string())

      reply = email.message_from_string(buf)

      self.send_email(reply)

   def cmd_info(self, args):
      logger.debug('cmd_info(args=%s)' % repr(args))

      self.show_info()

   def cmd_project(self, args):
      logger.debug('cmd_project(args=%r)' % repr(args))

      if args.index == None:
         self.output('Projects:')
         i = 0
         for project in self.projects:
            if self.project == project:
               selected = '*'
            else:
               selected = ' '

            self.output('%s %d: %s' % (selected, i, project.name))

            i += 1

         return

      try:
         index = int(args.index)
      except ValueError as e:
         self.output('Failed to convert index to integer: %s' % e)
         return

      self.project = self.projects[index]

      self.output('Switched to project: %s' % (self.project.name))

   def run_shell(self):
      self.parser = argparse.ArgumentParser(description='pwcli shell', prog='',
                                    add_help=False)
   
      subparsers = self.parser.add_subparsers()

      subparsers.add_parser('help').set_defaults(func=self.cmd_help)

      subparsers.add_parser('quit').set_defaults(func=self.cmd_quit)
      subparsers.add_parser('q').set_defaults(func=self.cmd_quit)

      parser_list = subparsers.add_parser('list')
      parser_list.add_argument('state', metavar='STATE', nargs='?',
                               help='optional patch state (new, review, upstream)')
      parser_list.set_defaults(func=self.cmd_list)

      parser_commit = subparsers.add_parser('commit')
      parser_commit.add_argument('ids', metavar='IDs', nargs='+')
      parser_commit.set_defaults(func=self.cmd_commit)

      parser_review = subparsers.add_parser('review')
      parser_review.add_argument('ids', metavar='IDs', nargs='+')
      parser_review.set_defaults(func=self.cmd_review)

      parser_show = subparsers.add_parser('show')
      parser_show.add_argument('id', metavar='ID', nargs=1)
      parser_show.set_defaults(func=self.cmd_show)

      parser_reply = subparsers.add_parser('reply')
      parser_reply.add_argument('id', metavar='ID', nargs=1)
      parser_reply.set_defaults(func=self.cmd_reply)

      parser_project = subparsers.add_parser('project')
      parser_project.add_argument('index', metavar='INDEX', nargs='?')
      parser_project.set_defaults(func=self.cmd_project)

      subparsers.add_parser('info').set_defaults(func=self.cmd_info)

      while True:
         prompt = ''

         prompt += '%s@%s ' % (self.git.get_branch(), self.tree)

         if self.dry_run:
            prompt += '(dry-run)'

         prompt += '> '

         cmd = self.input(prompt)

         # argparse is idiotic and exits if there's a parse error,
         # workaround it by catching SystemExit. Idea from:
         #
         # http://bugs.python.org/issue9938
         try:
            args = self.parser.parse_args(cmd.split())
         except SystemExit:
            continue

         args.func(args)

   def print_header(self, name, value):
      fmt = "%- 14s: %s"
      self.output(fmt % (name, value))

   def output(self, buf):
      logger.debug('> \'%s\'' % buf)
      print buf

   def input(self, prompt):
      logger.debug('> \'%s\'' % prompt)
      cmd = raw_input(prompt)
      logger.debug('< \'%s\'' % cmd)

      return cmd

   def __init__(self):

      if 'GIT_DIR' in os.environ:
         self.git_dir = os.environ['GIT_DIR']
      else:
         self.git_dir = '.git'

      self.pwcli_dir = os.path.join(self.git_dir, 'pwcli')
      self.config_file = os.path.join(self.pwcli_dir, 'config')

      if not os.path.exists(self.pwcli_dir):
         print '%s does not exist, exiting' % self.pwcli_dir
         sys.exit(1)

      if not os.path.isdir(self.pwcli_dir):
         print '%s is not a directory, exiting' % self.pwcli_dir
         sys.exit(1)

      if os.path.exists(PWCLI_EDIT_FILE):
         print '%s exists, remove and try again.' % PWCLI_EDIT_FILE
         sys.exit(1)

      logging.basicConfig(filename=os.path.join(self.pwcli_dir, 'log'),
                          format='%(asctime)s %(levelname)s: %(message)s')

      parser = argparse.ArgumentParser(description='Patchwork Command-Line Interface')
      parser.add_argument('-d', '--debug', action='store_true',
                          help='enable debug messages')

      parser.add_argument('--dry-run', action='store_true',
                          help='Don\'t modify anything')

      args = parser.parse_args()

      if args.debug:
         logger.setLevel(logging.DEBUG)

      logger.debug('pwcli args %s)' % repr(args))

      self.dry_run = args.dry_run

      self.config = ConfigParser.RawConfigParser()

      if not os.path.exists(self.config_file):
         print 'Could not find %s', self.config_file
         sys.exit(1)

      self.config.read(self.config_file)

      # read settings from pwcli config file
      self.url = self.config.get('general', 'url')
      self.username = self.config.get('general', 'username')
      self.password = self.config.get('general', 'password')
      self.project_names = self.config.get('general', 'project')

      self.project_names = self.project_names.split()

      # FIXME: ConfigParser supports providing defaults as a dict, use
      # those instead. Also maybe it's better to use self.config
      # directly and get rid of self.foo properties?

      if self.config.has_option('general', 'default_filter_delegated'):
         self.default_filter_delegated = self.config.getboolean('general',
                                                                'default_filter_delegated')
      else:
         self.default_filter_delegated = True

      pending_modes = ['disabled', 'stgit']

      # defaults
      self.pending_mode = 'disabled'
      self.pending_branch = None
      self.main_branch = None

      if self.config.has_option('general', 'pending_mode'):
         self.pending_mode = self.config.get('general', 'pending_mode').lower()

      if self.pending_mode not in pending_modes:
         self.output('Invalid stgit.mode "%s"' % self.pending_mode)
         sys.exit(1)

      if self.config.has_option('general', 'pending_branch'):
         self.pending_branch = self.config.get('general', 'pending_branch').lower()

      if self.config.has_option('general', 'main_branch'):
         self.main_branch = self.config.get('general', 'main_branch').lower()

      if self.pending_mode == 'stgit':
         if self.pending_branch == None:
            self.output('general.pending_branch not set')
            sys.exit(1)

         if self.main_branch == None:
            self.output('general.main_branch not set')
            sys.exit(1)

      # read settings from environment variables
      if 'EDITOR' in os.environ:
         self.editor = os.environ['EDITOR']
      else:
         self.editor = DEFAULT_EDITOR

      self.git = Git(self.dry_run, self.output)
      self.stg = Stg(self.dry_run, self.output)

      # read settings from git
      self.fullname = self.git.get_config('user.name')
      self.email = self.git.get_config('user.email')
      self.smtp_host = self.git.get_config('sendemail.smtpserver')
      self.smtp_port = self.git.get_config('sendemail.smtpserverport')
      self.smtp_encryption = self.git.get_config('sendemail.smtpencryption')
      self.smtp_username = self.git.get_config('sendemail.smtpuser')
      self.smtp_password = self.git.get_config('sendemail.smtppass')

      # print configs to debug log
      logger.debug('fullname=%s' % self.fullname)
      logger.debug('email=%s' % self.email)
      logger.debug('url=%s' % self.url)
      logger.debug('username=%s' % self.username)
      logger.debug('project_name=%s' % self.project_names)
      logger.debug('editor=%s' % self.editor)
      logger.debug('smtp_host=%s' % self.smtp_host)
      logger.debug('smtp_port=%s' % self.smtp_port)
      logger.debug('smtp_encryption=%s' % self.smtp_encryption)
      logger.debug('smtp_username=%s' % self.smtp_username)

      if self.smtp_password != None:
         passwd = '<hidden>'
      else:
         passwd = '<not set>'

      logger.debug('smtp_password=%s' % passwd)
      
      self.output('Connecting to %s' % self.url)

      self.pw = Patchwork(self.url, self.username, self.password)

      self.projects = []
      for project_name in self.project_names:
         self.projects.append(Project(project_name, self.pw, self.dry_run))

      # select the first project as initial project
      self.project = self.projects[0]

      self.user_ids = self.pw.get_user_ids(self.username)
      self.tree = os.path.basename(os.getcwd())

      self.patches = None

      self.show_info()

def main():
   pwcli = PWCLI()
   pwcli.run_shell()

if __name__ == "__main__":
   main()
