#!/usr/bin/env python
#
# Copyright (c) 2015, The Linux Foundation.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

import argparse
import sys
import os
import os.path
import ConfigParser
import hashlib
import email
import re

gitdir = None

# stub repository directory layout, location defined in
# STUB_GIT_DATADIR:
#
# objects/commits - list of commits, head commit last
# objects/<commitid> - commit object, patch in ascii format
# branches - list of branches, same as output from git-branch
# config - config file, almost same format as in real git but using ConfigParser

def cmd_branch(args):
      f = open(os.path.join(gitdir, 'branches'), 'r')
      print f.read()
      f.close()

def cmd_am_conflict(args):
      conflict_msg = '''Applying: foo: conflict patch
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
Auto-merging foo/bar.c
CONFLICT (content): Merge conflict in drivers/net/wireless/ath/foo/core.h
Failed to merge in the changes.
Patch failed at 0001 foo: conflict patch
When you have resolved this problem run "git am --resolved".
If you would prefer to skip this patch, instead run "git am --skip".
To restore the original branch and stop patching run "git am --abort".'''

      # git 1.7.9.5 prints the whole message to stdout and nothing to stderr
      sys.stdout.write(conflict_msg)

      sys.exit(1)

def cmd_am(args):
      if not args.s:
            # -s switch not used, exit
            sys.exit(0)

      conflict_file = os.path.join(gitdir, 'conflict')
      if os.path.exists(conflict_file):
            cmd_am_conflict(args)
            os.remove(conflict_file)
      
      objectsdir = os.path.join(gitdir, 'objects')
      commitsfile = os.path.join(objectsdir, 'commits')

      if not os.path.isdir(objectsdir):
            os.mkdir(objectsdir)

      buf = sys.stdin.read()
      sha1sum = hashlib.sha1(buf).hexdigest()

      f = open(commitsfile, 'a')
      f.write(sha1sum + '\n')
      f.close()

      f = open(os.path.join(objectsdir, sha1sum), 'w')
      f.write(buf)
      f.close()

def cmd_config(args):
      if not args.get:
            # for now we only support --get
            sys.exit(1)

      names = args.get[0].split('.')
      section = names[0]
      name = names[1]

      config = ConfigParser.RawConfigParser()
      config.read(os.path.join(gitdir, 'config'))

      if not config.has_option(section, name):
            print '%s not found' % name
            sys.exit(1)

      print config.get(section, name)

def get_commit_subject(commit):
      objectsdir = os.path.join(gitdir, 'objects')

      f = open(os.path.join(objectsdir, commit), 'r')
      buf = f.read()
      f.close()

      msg = email.message_from_string(buf)

      subject = msg['Subject']

      # remove all '[foo]' tags
      subject = re.sub('\[.*\]', '', subject)
      subject = subject.strip()

      return subject

def cmd_log(args):
      # FIXME: only support --oneline and --max-count for now

      objectsdir = os.path.join(gitdir, 'objects')
      commitsfile = os.path.join(objectsdir, 'commits')

      f = open(commitsfile, 'r')
      buf = f.read()
      f.close()

      commits = buf.splitlines()

      if len(args.max_count) > 0:
            max_count = int(args.max_count[0])

            # The commits file is in reversed order, HEAD is in the
            # bottom so need to take the last commits.
            commits = commits[-max_count:]

            for commit in commits:
                  subject = get_commit_subject(commit)

                  print '%.12s %s' % (commit, subject)

def cmd_show(args):
      # FIXME: only support HEAD for now
      if args.commitid != 'HEAD':
            print 'Unsupported commit id: %s' % (args.commitid)
            return

      objectsdir = os.path.join(gitdir, 'objects')
      commitsfile = os.path.join(objectsdir, 'commits')

      f = open(commitsfile, 'r')
      buf = f.read()
      f.close()

      commits = buf.splitlines()

      print 'commit %s' % (commits[0])

def cmd_cherry_pick(args):
      objectsdir = os.path.join(gitdir, 'objects')
      commitsfile = os.path.join(objectsdir, 'commits')

      commit_id = args.commit_id
      commit_path = os.path.join(objectsdir, commit_id)

      if not os.path.exists(commit_path):
            print 'Commit id %s not found.' % (commit_id)
            sys.exit(1)

      f = open(commitsfile, 'a')
      f.write(commit_id + '\n')
      f.close()

def cmd_checkout(args):
      # FIXME: just a dummy command for now
      pass

def cmd_filter_branch(args):
      # FIXME: just a dummy command for now
      pass

def main():
      global gitdir

      if 'STUB_GIT_DATADIR' in os.environ:
            gitdir = os.environ['STUB_GIT_DATADIR']
      else:
            gitdir = '.'

      parser = argparse.ArgumentParser(description='git-stub', prog='',
                                       add_help=False)

      parser.add_argument('--version', action='store_true')

      subparsers = parser.add_subparsers()
      subparsers.add_parser('branch').set_defaults(func=cmd_branch)

      parser_am = subparsers.add_parser('am')
      parser_am.add_argument('-s', action='store_true')
      parser_am.add_argument('-3', action='store_true')
      parser_am.set_defaults(func=cmd_am)

      parser_config = subparsers.add_parser('config')
      parser_config.add_argument('--get', nargs=1, action='store')
      parser_config.set_defaults(func=cmd_config)

      parser_log = subparsers.add_parser('log')
      parser_log.add_argument('--oneline', action='store_true')
      parser_log.add_argument('--reverse', action='store_true')
      parser_log.add_argument('--max-count', nargs=1, action='store')
      parser_log.set_defaults(func=cmd_log)

      parser_show = subparsers.add_parser('show')
      parser_show.add_argument('commitid')
      parser_show.set_defaults(func=cmd_show)

      parser_cherry_pick = subparsers.add_parser('cherry-pick')
      parser_cherry_pick.add_argument('commit_id')
      parser_cherry_pick.set_defaults(func=cmd_cherry_pick)

      parser_checkout = subparsers.add_parser('checkout')
      parser_checkout.add_argument('branch')
      parser_checkout.set_defaults(func=cmd_checkout)

      parser_filter_branch = subparsers.add_parser('filter-branch')
      parser_filter_branch.add_argument('--force', action='store_true')
      parser_filter_branch.add_argument('--msg-filter', nargs=2)
      parser_filter_branch.set_defaults(func=cmd_filter_branch)

      args = parser.parse_args()

      if args.version:
            # Print a version string so that test scripts can verify
            # that this really is a stub and not playing with a real
            # git repo.
            #
            # Note: have to be called with 'git --version branch' as I
            # didn't know how to implement 'git --version' with
            # argparse
            print 'stub-git'
            print 'STUB_GIT_DATADIR=%s' % gitdir
            sys.exit(0)

      args.func(args)

if __name__ == "__main__":
      main()
